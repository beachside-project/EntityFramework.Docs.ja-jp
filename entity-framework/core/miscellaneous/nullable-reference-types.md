---
title: Null 許容の参照型の使用-EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: c16a475c363320cd18804a4efe78ccae1ae22f0d
ms.sourcegitcommit: f2a38c086291699422d8b28a72d9611d1b24ad0d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/16/2020
ms.locfileid: "76124354"
---
# <a name="working-with-nullable-reference-types"></a><span data-ttu-id="35bc8-102">Null 許容の参照型の使用</span><span class="sxs-lookup"><span data-stu-id="35bc8-102">Working with Nullable Reference Types</span></span>

<span data-ttu-id="35bc8-103">C#8では、null 値を[許容する参照型](/dotnet/csharp/tutorials/nullable-reference-types)と呼ばれる新しい機能が導入されました。これにより、参照型に注釈を付け、null を含むかどうかを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-103">C# 8 introduced a new feature called [nullable reference types](/dotnet/csharp/tutorials/nullable-reference-types), allowing reference types to be annotated, indicating whether it is valid for them to contain null or not.</span></span> <span data-ttu-id="35bc8-104">この機能を初めて使用する場合は、 C#ドキュメントを読むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="35bc8-104">If you are new to this feature, it is recommended that make yourself familiar with it by reading the C# docs.</span></span>

<span data-ttu-id="35bc8-105">このページでは、null 許容の参照型に対する EF Core のサポートについて説明し、それらを操作するためのベストプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="35bc8-105">This page introduces EF Core's support for nullable reference types, and describes best practices for working with them.</span></span>

## <a name="required-and-optional-properties"></a><span data-ttu-id="35bc8-106">必須および省略可能なプロパティ</span><span class="sxs-lookup"><span data-stu-id="35bc8-106">Required and optional properties</span></span>

<span data-ttu-id="35bc8-107">必須およびオプションのプロパティに関する主なドキュメントと、null 許容の参照型との相互作用については、[必須プロパティと省略可能なプロパティ](xref:core/modeling/entity-properties#required-and-optional-properties)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="35bc8-107">The main documentation on required and optional properties and their interaction with nullable reference types is the [Required and Optional Properties](xref:core/modeling/entity-properties#required-and-optional-properties) page.</span></span> <span data-ttu-id="35bc8-108">まず最初にこのページを読むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="35bc8-108">It is recommended you start out by reading that page first.</span></span>

> [!NOTE]
> <span data-ttu-id="35bc8-109">既存のプロジェクトで null 値を許容する参照型を有効にする場合は注意してください。以前にオプションとして構成されていた参照型プロパティは、明示的に null 値が指定されていない限り、必須として構成されます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-109">Exercise caution when enabling nullable reference types on an existing project: reference type properties which were previously configured as optional will now be configured as required, unless they are explicitly annotated to be nullable.</span></span> <span data-ttu-id="35bc8-110">リレーショナルデータベーススキーマを管理する場合、これにより、データベース列の null 値の許容属性を変更する移行が生成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-110">When managing a relational database schema, this may cause migrations to be generated which alter the database column's nullability.</span></span>

## <a name="dbcontext-and-dbset"></a><span data-ttu-id="35bc8-111">DbContext と Dbcontext</span><span class="sxs-lookup"><span data-stu-id="35bc8-111">DbContext and DbSet</span></span>

<span data-ttu-id="35bc8-112">Null 値を許容する参照型がC#有効になっている場合、初期化されていない null 以外のプロパティについては、コンパイラによって警告が出力されます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-112">When nullable reference types are enabled, the C# compiler emits warnings for any uninitialized non-nullable property, as these would contain null.</span></span> <span data-ttu-id="35bc8-113">その結果、コンテキストで null 非許容の `DbSet` を定義する一般的な方法では、警告が生成されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="35bc8-113">As a result, the common practice of defining a non-nullable `DbSet` on a context will now generate a warning.</span></span> <span data-ttu-id="35bc8-114">ただし、EF Core は常に DbContext 派生型のすべての `DbSet` プロパティを初期化するので、コンパイラがこれを認識しない場合でも、必ず null にならないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-114">However, EF Core always initializes all `DbSet` properties on DbContext-derived types, so they are guaranteed to never be null, even if the compiler is unaware of this.</span></span> <span data-ttu-id="35bc8-115">したがって、`DbSet` のプロパティを null 非許容にすることをお勧めします。 null チェックを行わずにこれらのプロパティにアクセスできるようにします。また、null 非対応演算子 (!) を使用して明示的に null に設定することにより、コンパイラの警告をサイレント状態にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-115">Therefore, it is recommended to keep your `DbSet` properties non-nullable - allowing you to access them without null checks - and to silence the compiler warnings by explicitly setting them to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a><span data-ttu-id="35bc8-116">Null 非許容のプロパティと初期化</span><span class="sxs-lookup"><span data-stu-id="35bc8-116">Non-nullable properties and initialization</span></span>

<span data-ttu-id="35bc8-117">初期化されていない null 非許容の参照型に対するコンパイラの警告は、エンティティ型の通常のプロパティにも問題があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-117">Compiler warnings for uninitialized non-nullable reference types are also a problem for regular properties on your entity types.</span></span> <span data-ttu-id="35bc8-118">上記の例では、コンストラクターバインディングを使用して、これらの警告を回避しました。[コンストラクターバインド](xref:core/modeling/constructors)は、null 非許容のプロパティで完全に動作する機能であり、常に初期化されていることを保証します。</span><span class="sxs-lookup"><span data-stu-id="35bc8-118">In our example above, we avoided these warnings by using [constructor binding](xref:core/modeling/constructors), a feature which works perfectly with non-nullable properties, ensuring they are always initialized.</span></span> <span data-ttu-id="35bc8-119">ただし、シナリオによっては、コンストラクターバインドがオプションではない場合があります。たとえば、ナビゲーションプロパティをこの方法で初期化することはできません。</span><span class="sxs-lookup"><span data-stu-id="35bc8-119">However, in some scenarios constructor binding isn't an option: navigation properties, for example, cannot be initialized in this way.</span></span>

<span data-ttu-id="35bc8-120">必須のナビゲーションプロパティでは、特定のプリンシパルに依存関係が常に存在しますが、プログラムのその時点でのニーズに応じて、特定のクエリによって読み込まれないことがあります ([データを読み込むためのさまざまなパターンを参照してください](xref:core/querying/related-data))。</span><span class="sxs-lookup"><span data-stu-id="35bc8-120">Required navigation properties present an additional difficulty: although a dependent will always exist for a given principal, it may or may not be loaded by a particular query, depending on the needs at that point in the program ([see the different patterns for loading data](xref:core/querying/related-data)).</span></span> <span data-ttu-id="35bc8-121">同時に、これらのプロパティを null 許容にすることは望ましくありません。これは、必要に応じて、これらのプロパティへのすべてのアクセスが null をチェックするようにするためです。</span><span class="sxs-lookup"><span data-stu-id="35bc8-121">At the same time, it is undesirable to make these properties nullable, since that would force all access to them to check for null, even if they are required.</span></span>

<span data-ttu-id="35bc8-122">これらのシナリオを処理する方法の1つは、null 許容の[バッキングフィールド](xref:core/modeling/backing-field)を持つ null 非許容プロパティを持つことです。</span><span class="sxs-lookup"><span data-stu-id="35bc8-122">One way to deal with these scenarios, is to have a non-nullable property with a nullable [backing field](xref:core/modeling/backing-field):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

<span data-ttu-id="35bc8-123">ナビゲーションプロパティは null 非許容であるため、必要なナビゲーションが構成されます。また、ナビゲーションが適切に読み込まれている限り、依存するにはプロパティを使用してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-123">Since the navigation property is non-nullable, a required navigation is configured; and as long as the navigation is properly loaded, the dependent will be accessible via the property.</span></span> <span data-ttu-id="35bc8-124">ただし、最初に関連エンティティを適切に読み込むことなく、プロパティにアクセスした場合は、API コントラクトが正しく使用されていないため、InvalidOperationException がスローされます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-124">If, however, the property is accessed without first properly loading the related entity, an InvalidOperationException is thrown, since the API contract has been used incorrectly.</span></span> <span data-ttu-id="35bc8-125">EF は、プロパティではなく、常にバッキングフィールドにアクセスするように構成する必要があることに注意してください。これは、設定が解除された場合でも値を読み取ることができるようにするためです。この方法については、[バックアップフィールド](xref:core/modeling/backing-field)に関するドキュメントを参照してください。 `PropertyAccessMode.Field` を指定して、構成が正しいことを確認することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="35bc8-125">Note that EF must be configured to always access the backing field and not the property, as it relies on being able to read the value even when unset; consult the documentation on [backing fields](xref:core/modeling/backing-field) on how to do this, and consider specifying `PropertyAccessMode.Field` to make sure the configuration is correct.</span></span>

<span data-ttu-id="35bc8-126">Terser として、null に対応していない演算子 (!) のヘルプを使用して、単純にプロパティを null に初期化することができます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-126">As a terser alternative, it is possible to simply initialize the property to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

<span data-ttu-id="35bc8-127">実際の null 値は、プログラミングのバグの結果としては決して観察されません。たとえば、関連エンティティを事前に適切に読み込むことなくナビゲーションプロパティにアクセスする場合などです。</span><span class="sxs-lookup"><span data-stu-id="35bc8-127">An actual null value will never be observed except as a result of a programming bug, e.g. accessing the navigation property without properly loading the related entity beforehand.</span></span>

> [!NOTE]
> <span data-ttu-id="35bc8-128">複数の関連エンティティへの参照を含むコレクションナビゲーションは、常に null 非許容にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-128">Collection navigations, which contain references to multiple related entities, should always be non-nullable.</span></span> <span data-ttu-id="35bc8-129">空のコレクションは、関連するエンティティが存在しないことを意味しますが、リスト自体を null にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="35bc8-129">An empty collection means that no related entities exist, but the list itself should never be null.</span></span>

## <a name="navigating-and-including-nullable-relationships"></a><span data-ttu-id="35bc8-130">Null 許容リレーションシップの移動と操作</span><span class="sxs-lookup"><span data-stu-id="35bc8-130">Navigating and including nullable relationships</span></span>

<span data-ttu-id="35bc8-131">オプションのリレーションシップを処理する場合、実際の null 参照例外が発生しないというコンパイラの警告が表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-131">When dealing with optional relationships, it's possible to encounter compiler warnings where an actual null reference exception would be impossible.</span></span> <span data-ttu-id="35bc8-132">LINQ クエリの変換と実行時に、オプションの関連エンティティが存在しない場合は、スローされるのではなく、その関連エンティティへのナビゲーションが無視されることが EF Core 保証されます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-132">When translating and executing your LINQ queries, EF Core guarantees that if an optional related entity does not exist, any navigation to it will simply be ignored, rather than throwing.</span></span> <span data-ttu-id="35bc8-133">ただし、コンパイラはこの EF Core 保証を認識しないため、LINQ クエリがメモリ内で実行されたかのように、LINQ to Objects を使用して警告を生成します。</span><span class="sxs-lookup"><span data-stu-id="35bc8-133">However, the compiler is unaware of this EF Core guarantee, and produces warnings as if the LINQ query were executed in memory, with LINQ to Objects.</span></span> <span data-ttu-id="35bc8-134">結果として、null を許容しない演算子 (!) を使用して、実際の null 値が不可能であることをコンパイラに通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-134">As a result, it is necessary to use the null-forgiving operator (!) to inform the compiler that an actual null value isn't possible:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

<span data-ttu-id="35bc8-135">次のような場合にも同様の問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="35bc8-135">A similar issue occurs when including multiple levels of relationships across optional navigations:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

<span data-ttu-id="35bc8-136">これを頻繁に実行し、問題のエンティティ型が EF Core クエリで主に (または排他的に) 使用されている場合は、ナビゲーションプロパティを null 非許容にし、Fluent API またはデータ注釈を使用してオプションとして構成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="35bc8-136">If you find yourself doing this a lot, and the entity types in question are predominantly (or exclusively) used in EF Core queries, consider making the navigation properties non-nullable, and to configure them as optional via the Fluent API or Data Annotations.</span></span> <span data-ttu-id="35bc8-137">これにより、リレーションシップを省略可能にしたまま、すべてのコンパイラ警告が削除されます。ただし、EF Core の外部でエンティティを走査した場合、プロパティには null 非許容として注釈が付けられますが、null 値を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-137">This will remove all compiler warnings while keeping the relationship optional; however, if your entities are traversed outside of EF Core, you may observe null values although the properties are annotated as non-nullable.</span></span>

## <a name="limitations"></a><span data-ttu-id="35bc8-138">制限事項</span><span class="sxs-lookup"><span data-stu-id="35bc8-138">Limitations</span></span>

* <span data-ttu-id="35bc8-139">リバースエンジニアリングでは、現在、 [ C# 8 つの null 値を許容する参照型 (nrts)](/dotnet/csharp/tutorials/nullable-reference-types)はサポートされていません。 EF Core は、機能が無効であると仮定するコードを常に生成C#します。</span><span class="sxs-lookup"><span data-stu-id="35bc8-139">Reverse engineering does not currently support [C# 8 nullable reference types (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core always generates C# code that assumes the feature is off.</span></span> <span data-ttu-id="35bc8-140">たとえば、null 値が許容されるテキスト列は、プロパティが必要かどうかを構成するために使用される Fluent API またはデータ注釈が `string?`ではなく `string` 型のプロパティとしてスキャフォールディングされます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-140">For example, nullable text columns will be scaffolded as a property with type `string` , not `string?`, with either the Fluent API or Data Annotations used to configure whether a property is required or not.</span></span> <span data-ttu-id="35bc8-141">スキャフォールディングコードを編集し、null 値を許容C#する注釈に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-141">You can edit the scaffolded code and replace these with C# nullability annotations.</span></span> <span data-ttu-id="35bc8-142">Null 許容型参照型のスキャフォールディングサポートは、 [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520)問題によって追跡されます。</span><span class="sxs-lookup"><span data-stu-id="35bc8-142">Scaffolding support for nullable reference types is tracked by issue [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).</span></span>
* <span data-ttu-id="35bc8-143">EF Core のパブリック API サーフェイスには、null 値の許容属性 (パブリック API が "無関係") に対してまだ注釈が付けられていないため、NRT 機能が有効になっているときに使用するのが困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="35bc8-143">EF Core's public API surface has not yet been annotated for nullability (the public API is "null-oblivious"), making it sometimes awkward to use when the NRT feature is turned on.</span></span> <span data-ttu-id="35bc8-144">これには、特に、EF Core によって公開される非同期 LINQ 演算子 (たとえば、「」を含む) が含ま[れます。](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_)</span><span class="sxs-lookup"><span data-stu-id="35bc8-144">This notably includes the async LINQ operators exposed by EF Core, such as [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span></span> <span data-ttu-id="35bc8-145">5\.0 リリースでは、このことに対処する予定です。</span><span class="sxs-lookup"><span data-stu-id="35bc8-145">We plan to address this for the 5.0 release.</span></span>
